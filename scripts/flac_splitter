#!/usr/bin/env bash
#
# flac_splitter.sh
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Mohamad Adithya
#
# flac_splitter
# Split a single FLAC file using a CUE sheet, or just tag files directly for
# multi-FILE CUE sheets (no splitting).
#
# Target: macOS bash 3.2 (no mapfile, no nameref).
#
# Features:
#   - Export CUE from FLAC if not provided
#   - Convert CUE encoding ‚Üí UTF-8 (manual or best-guess)
#   - Normalize ‚Äúfancy‚Äù quotes and ellipsis ‚Üí ASCII-safe characters
#   - Handle mismatched track counts (pregap policy: auto | keep | drop)
#   - Tagging via cuetag / cuetag.sh
#   - Embed album cover (cover.jpg / cover.png)
#   - Detect ‚Äúextra‚Äù tracks and handle them (keep | move | delete)
#   - Sanitize output filenames so they are safe across OS/filesystems
#

set -euo pipefail

# Force UTF-8 locale so awk/sed do not choke on multibyte chars
export LC_ALL="${LC_ALL:-en_US.UTF-8}"
export LANG="${LANG:-en_US.UTF-8}"
export LC_CTYPE="${LC_CTYPE:-en_US.UTF-8}"

# =========================
# Global / default options
# =========================
CUE=""
FLAC=""
OUTDIR="split"
TEMPLATE="%n - %t"

SKIP_COVER="0"
CONVERT_CUE_FROM=""
PREGAP_POLICY="auto"      # auto | keep | drop
EXTRAS_ACTION="keep"      # keep | move | delete

EXTRAS=()

BREW_PREFIX="$(brew --prefix 2>/dev/null || true)"
CUETAG_BIN=""
ICONV_AVAIL=0
GSORT_PATH=""

SCRIPT_NAME="$(basename "$0")"

# =========================
# Logging helpers
# =========================
log()  { echo "üõà $*"; }
warn() { echo "‚ö†Ô∏è  $*" >&2; }
die()  { echo "‚ùå $*" >&2; exit 1; }

need() {
  command -v "$1" >/dev/null 2>&1 || return 1
}

print_usage() {
  cat <<EOF
flac_splitter ‚Äì Split and tag FLAC albums using CUE sheets

Usage:
  ${SCRIPT_NAME} -f FILE.flac [options]

Required:
  -f FILE.flac          Input FLAC image file

Optional:
  -c FILE.cue           CUE sheet to use
                        If omitted, the script will try to export an embedded
                        CUE sheet from the FLAC file (via metaflac).
  -o OUTDIR             Output directory for split tracks
                        Default: split
  -t TEMPLATE           shnsplit template (default: "%n - %t")
                        Example: "%n - %p - %t"

Cover / metadata:
  --no-cover            Do not embed cover art (cover.jpg / cover.png)
  --iconv-from ENC      Force CUE encoding conversion ENC ‚Üí UTF-8
                        Example: WINDOWS-1252, SHIFT_JIS, ISO-8859-1

Pregap & extras handling:
  --pregap-policy MODE  How to handle track-count mismatches:
                        - auto (default): abort if counts still mismatch
                        - keep: allow mismatch and continue tagging
                        - drop: (alias of auto, kept for compatibility)
  --extras-action ACT   What to do with extra split files (beyond CUE tracks):
                        - keep   (default) ‚Äì leave as-is
                        - move   ‚Äì move into OUTDIR/_extras
                        - delete ‚Äì delete extras (use with care)

Examples:
  # 1) Simple split: FLAC has embedded CUE
  ${SCRIPT_NAME} -f album.flac

  # 2) Split with external CUE and custom output dir
  ${SCRIPT_NAME} -f album.flac -c album.cue -o out

  # 3) Force CUE encoding conversion from Windows-1252
  ${SCRIPT_NAME} -f album.flac --iconv-from WINDOWS-1252

Notes:
  - For single-FILE CUE: the FLAC image is split and tagged.
  - For multi-FILE CUE: no splitting is done; existing per-track files
    are tagged and optionally have cover art embedded.
EOF
}

# =========================
# Arg parsing
# =========================
parse_args() {
  [[ $# -eq 0 ]] && { print_usage; exit 1; }

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c) CUE="${2:-}"; shift 2 ;;
      -f) FLAC="${2:-}"; shift 2 ;;
      -o) OUTDIR="${2:-}"; shift 2 ;;
      -t) TEMPLATE="${2:-}"; shift 2 ;;
      --no-cover) SKIP_COVER="1"; shift ;;
      --iconv-from) CONVERT_CUE_FROM="${2:-}"; shift 2 ;;
      --pregap-policy) PREGAP_POLICY="${2:-}"; shift 2 ;;
      --extras-action) EXTRAS_ACTION="${2:-}"; shift 2 ;;
      -h|--help) print_usage; exit 0 ;;
      *) die "Unknown argument: $1" ;;
    esac
  done
}

# =========================
# Env & dependencies
# =========================
setup_env_and_deps() {
  if [[ -n "$BREW_PREFIX" ]]; then
    export PATH="$BREW_PREFIX/bin:$PATH"
  fi

  need shnsplit  || die "'shnsplit' not found. Install with: brew install shntool"
  need metaflac  || die "'metaflac' not found. Install with: brew install flac"
  need flac      || die "'flac' not found. Install with: brew install flac"

  CUETAG_BIN="$(command -v cuetag || true)"
  if [[ -z "$CUETAG_BIN" ]]; then
    CUETAG_BIN="$(command -v cuetag.sh || true)"
  fi
  if [[ -z "$CUETAG_BIN" && -n "$BREW_PREFIX" && -x "$BREW_PREFIX/bin/cuetag.sh" ]]; then
    CUETAG_BIN="$BREW_PREFIX/bin/cuetag.sh"
  fi
  [[ -z "$CUETAG_BIN" ]] && die "'cuetag' not found. Install with: brew install cuetools"

  if need iconv; then
    ICONV_AVAIL=1
  else
    ICONV_AVAIL=0
  fi

  GSORT_PATH="$(command -v gsort 2>/dev/null || true)"
}

# =========================
# CUE helpers
# =========================

# Count number of FILE entries in CUE
cue_file_count() {
  awk '
    /^[[:space:]]*FILE[[:space:]]+\".*\"/ {count++}
    END{print count+0}
  ' "$1"
}

# Count number of audio TRACKs (ignore DATA)
count_cue_audio_tracks() {
  awk '
    BEGIN{count=0}
    /^[[:space:]]*TRACK[[:space:]]+[0-9]{2}([[:space:]]+[A-Za-z0-9._+-]+)?/ {
      t=toupper($3)
      if (t=="" || t=="AUDIO") count++
      else if (t!="DATA") count++
    }
    END{print count}
  ' "$1"
}

# Read TRACK-level TITLEs from CUE
read_cue_track_titles() {
  awk '
    BEGIN{in_audio=0}
    /^[[:space:]]*TRACK[[:space:]]+[0-9]{2}([[:space:]]+[A-Za-z0-9._+-]+)?/ {
      t=toupper($3)
      if (t=="" || t=="AUDIO") in_audio=1;
      else if (t!="DATA") in_audio=1;
      else in_audio=0;
    }
    /^[[:space:]]*TITLE[[:space:]]+\"/ {
      if (in_audio==1) {
        line=$0
        i=index(line, "\"")
        if (i>0) {
          rest=substr(line, i+1)
          j=index(rest, "\"")
          if (j>0) {
            title=substr(rest, 1, j-1)
            if (length(title)>0) print title
          }
        }
      }
    }
  ' "$1"
}

# Normalize ‚Äúsmart‚Äù quotes / ellipsis ‚Üí plain ASCII
normalize_cue_quotes() {
  local cue_path="$1"
  local norm_path="${cue_path%.cue}.norm.cue"

  # Use LC_ALL=C for BSD sed compatibility
  LC_ALL=C sed \
    -e "s/‚Äô/'/g" \
    -e 's/‚Äú/"/g' \
    -e 's/‚Äù/"/g' \
    -e 's/‚Ä¶/.../g' \
    "$cue_path" > "$norm_path"

  echo "$norm_path"
}

# Prepare CUE: export from FLAC if needed, convert encoding, normalize quotes
prepare_cue() {
  [[ -z "$FLAC" ]] && { print_usage; die "You must provide -f FILE.flac"; }
  [[ -f "$FLAC" ]] || die "FLAC not found: $FLAC"

  local cue_path="$CUE"

  # If user gave -c but the file doesn't exist ‚Üí try to export from FLAC
  if [[ -n "$cue_path" && ! -f "$cue_path" ]]; then
    warn "CUE '$cue_path' not found; attempting to export from FLAC‚Ä¶"
    cue_path=""
  fi

  # If still empty ‚Üí export embedded CUE from FLAC
  if [[ -z "$cue_path" ]]; then
    local exported
    exported="$(dirname "$FLAC")/$(basename "${FLAC%.*}").cue"
    log "Exporting embedded CUE from FLAC ‚Üí '$exported'"
    if metaflac --export-cuesheet-to="$exported" "$FLAC" 2>/dev/null; then
      cue_path="$exported"
      log "Exported CUE: $cue_path"
    else
      die "No external CUE and FLAC does not contain an embedded cuesheet."
    fi
  fi

  # If user explicitly requested encoding conversion
  if [[ -n "$CONVERT_CUE_FROM" && $ICONV_AVAIL -eq 1 ]]; then
    local cue_utf8="${cue_path%.cue}-utf8.cue"
    log "Converting CUE encoding: $CONVERT_CUE_FROM ‚Üí UTF-8‚Ä¶"
    if iconv -f "$CONVERT_CUE_FROM" -t UTF-8 "$cue_path" > "$cue_utf8"; then
      cue_path="$cue_utf8"
      log "CUE converted: $cue_path"
    else
      warn "Failed to convert CUE encoding; using original."
    fi
  else
    # Best-effort guess: ISO-8859-1 ‚Üí UTF-8
    if [[ $ICONV_AVAIL -eq 1 ]]; then
      local cue_utf8_guess="${cue_path%.cue}-utf8.cue"
      if iconv -f ISO-8859-1 -t UTF-8 "$cue_path" > "$cue_utf8_guess" 2>/dev/null; then
        cue_path="$cue_utf8_guess"
        log "CUE converted (guess ISO-8859-1 ‚Üí UTF-8): $cue_path"
      fi
    fi
  fi

  # Finally, normalize ‚Äúsmart‚Äù quotes
  local norm_cue
  norm_cue="$(normalize_cue_quotes "$cue_path")"
  CUE="$norm_cue"
}

# =========================
# Multi-FILE CUE handling
# =========================

# List candidate audio files for multi-FILE mode
list_audio_candidates_multi() {
  local arr=()
  local ext f cuedir

  # Prefer OUTDIR if per-track files already exist there
  for ext in flac wav aiff aif; do
    for f in "$OUTDIR"/*."$ext"; do
      [[ -e "$f" ]] || break
      arr+=( "$f" )
    done
  done

  # If still empty, search in CUE directory
  if (( ${#arr[@]} == 0 )); then
    cuedir="$(dirname "$CUE")"
    for ext in flac wav aiff aif; do
      for f in "$cuedir"/*."$ext"; do
        [[ -e "$f" ]] || break
        arr+=( "$f" )
      done
    done
  fi

  for f in "${arr[@]}"; do
    echo "$f"
  done
}

# Multi-FILE CUE mode: no splitting, only tagging
process_multi_file_cue() {
  log "Detected multi-FILE CUE ‚Üí tagging existing per-track files."

  local existing=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && existing+=( "$line" )
  done < <(list_audio_candidates_multi)

  (( ${#existing[@]} > 0 )) || die "No per-track audio files found to tag."

  log "Writing tags using: $CUETAG_BIN"
  "$CUETAG_BIN" "$CUE" "${existing[@]}"

  if [[ "$SKIP_COVER" != "1" ]]; then
    local COVER_JPG
    local COVER_PNG
    COVER_JPG="$(dirname "$FLAC")/cover.jpg"
    COVER_PNG="$(dirname "$FLAC")/cover.png"

    if [[ -f "$COVER_JPG" ]]; then
      log "Embedding cover.jpg"
      metaflac --import-picture-from="$COVER_JPG" "${existing[@]}" || true
    elif [[ -f "$COVER_PNG" ]]; then
      log "Embedding cover.png"
      metaflac --import-picture-from="$COVER_PNG" "${existing[@]}" || true
    else
      log "No cover.jpg or cover.png found."
    fi
  fi

  echo "‚úÖ Done (multi-FILE mode)."
  exit 0
}

# =========================
# Splitting & track handling
# =========================

run_split() {
  mkdir -p "$OUTDIR"
  log "Splitting single-FILE FLAC‚Ä¶"
  log "FLAC   : $FLAC"
  log "CUE    : $CUE"
  log "OUTDIR : $OUTDIR"
  log "Format : $TEMPLATE"

  shnsplit -f "$CUE" -o flac -t "$TEMPLATE" -d "$OUTDIR" "$FLAC"
}

collect_split_tracks() {
  local tracks=()
  local f

  for f in "$OUTDIR"/*.flac; do
    [[ -e "$f" ]] || break
    tracks+=( "$f" )
  done

  [[ ${#tracks[@]} -eq 0 ]] && die "No split files found in '$OUTDIR'."

  if [[ -n "$GSORT_PATH" ]]; then
    printf '%s\n' "${tracks[@]}" | "$GSORT_PATH" -V
  else
    printf '%s\n' "${tracks[@]}"
  fi
}

total_samples() {
  local f="$1" s
  s="$(metaflac --show-total-samples "$f" 2>/dev/null | tail -n1 || true)"
  [[ -z "$s" ]] && s=9999999999
  echo "$s"
}

# Extract title from file name (default format: "01 - Title")
extract_title_from_file() {
  local p="$1"
  local base title

  base="$(basename "$p")"
  base="${base%.*}"

  if [[ "$base" =~ ^[0-9]{1,3}[[:space:]]*-[[:space:]]*(.*)$ ]]; then
    title="${BASH_REMATCH[1]}"
    [[ -z "$title" ]] && title="$base"
  else
    title="$base"
  fi

  echo "$title"
}

# =========================
# Cover & extras handling
# =========================

embed_cover_to_tracks() {
  local tracks=( "$@" )
  (( ${#tracks[@]} == 0 )) && return 0

  if [[ "$SKIP_COVER" == "1" ]]; then
    log "--no-cover set: skipping cover embedding."
    return 0
  fi

  local COVER_JPG
  local COVER_PNG
  COVER_JPG="$(dirname "$FLAC")/cover.jpg"
  COVER_PNG="$(dirname "$FLAC")/cover.png"

  if [[ -f "$COVER_JPG" ]]; then
    log "Embedding cover.jpg"
    metaflac --import-picture-from="$COVER_JPG" "${tracks[@]}" || true
  elif [[ -f "$COVER_PNG" ]]; then
    log "Embedding cover.png"
    metaflac --import-picture-from="$COVER_PNG" "${tracks[@]}" || true
  else
    log "No cover.jpg or cover.png found."
  fi
}

handle_extras_files() {
  if (( $# == 0 )); then
    log "Extras: none."
    return 0
  fi

  local extras=( "$@" )

  case "$EXTRAS_ACTION" in
    keep|"")
      log "Extras: keeping as-is. Count: ${#extras[@]}"
      ;;
    move)
      local extras_dir="$OUTDIR/_extras"
      mkdir -p "$extras_dir"
      log "Extras: moving ‚Üí $extras_dir"

      local xf base dest ts
      for xf in "${extras[@]}"; do
        base="$(basename "$xf")"
        dest="$extras_dir/$base"
        if [[ -e "$dest" ]]; then
          ts="$(date +%s)"
          dest="$extras_dir/${base%.*}_$ts.${base##*.}"
        fi
        mv -f "$xf" "$dest"
      done
      ;;
    delete)
      log "Extras: deleting"
      if command -v trash >/dev/null 2>&1; then
        trash "${extras[@]}" || true
      else
        rm -f -- "${extras[@]}"
      fi
      ;;
    *)
      warn "Unknown --extras-action: '$EXTRAS_ACTION' ‚Üí defaulting to keep"
      ;;
  esac
}

# =========================
# Filename sanitization
# =========================

# Sanitize a single filename component (no path)
sanitize_filename_component() {
  local name="$1"
  local base="$name"
  local ext=""

  # Split extension
  if [[ "$name" == *.* ]]; then
    ext=".${name##*.}"
    base="${name%.*}"
  fi

  # ASCII transliteration if iconv supports TRANSLIT
  if (( ICONV_AVAIL == 1 )); then
    base="$(printf '%s' "$base" | iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null || printf '%s' "$base")"
  fi

  # Replace unsafe characters ‚Üí underscore / safe
  base="$(printf '%s' "$base" | LC_ALL=C sed \
    -e 's/[\/\\:*?"<>|]/_/g' \
    -e "s/‚Äô/'/g" \
    -e 's/[‚Äú‚Äù]/"/g' \
    -e 's/‚Ä¶/.../g' \
  )"

  # Remove non-printable characters
  base="$(printf '%s' "$base" | tr -cd '[:print:]')"

  # Normalize whitespace ‚Üí single underscores
  base="$(printf '%s' "$base" | sed -E 's/[[:space:]]+/ /g')"
  base="$(printf '%s' "$base" | sed -E 's/ /_/g; s/_+/_/g')"

  # Trim leading/trailing underscores/dots
  base="${base##_}"
  base="${base%_}"
  base="${base#.}"
  base="${base%.}"

  # Ensure not empty
  [[ -z "$base" ]] && base="track"

  printf '%s%s\n' "$base" "$ext"
}

# Sanitize all .flac files in OUTDIR (called at the very end)
sanitize_output_filenames() {
  local dir="$OUTDIR"
  local f base newbase target count candidate

  shopt -s nullglob
  for f in "$dir"/*.flac; do
    base="$(basename "$f")"
    newbase="$(sanitize_filename_component "$base")"

    # Skip if unchanged
    if [[ "$base" == "$newbase" ]]; then
      continue
    fi

    target="$dir/$newbase"
    count=1

    # Avoid collisions
    while [[ -e "$target" ]]; do
      candidate="${newbase%.*}_$count.${newbase##*.}"
      target="$dir/$candidate"
      count=$((count+1))
    done

    log "Sanitizing filename: '$base' ‚Üí '$(basename "$target")'"
    mv -n -- "$f" "$target"
  done
  shopt -u nullglob
}

# =========================
# Main
# =========================
main() {
  parse_args "$@"
  setup_env_and_deps
  prepare_cue

  # Detect multi-FILE CUE
  local mf_count
  mf_count="$(cue_file_count "$CUE")"
  if (( mf_count > 1 )); then
    process_multi_file_cue
  fi

  # Single-FILE CUE ‚Üí split
  run_split

  # Collect all split tracks (sorted)
  local all_tracks=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && all_tracks+=( "$line" )
  done < <(collect_split_tracks)

  local cue_tracks
  cue_tracks="$(count_cue_audio_tracks "$CUE")"
  [[ -z "$cue_tracks" || "$cue_tracks" -le 0 ]] && die "Could not read TRACK count from CUE."

  local cue_titles=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && cue_titles+=( "$line" )
  done < <(read_cue_track_titles "$CUE")

  # Match filenames vs CUE TITLEs
  local recognized=()
  local unknown=()
  local f t ct

  for f in "${all_tracks[@]}"; do
    t="$(extract_title_from_file "$f")"
    local found=0
    for ct in "${cue_titles[@]}"; do
      if [[ "$t" == "$ct" ]]; then
        found=1
        break
      fi
    done
    if (( found == 1 )); then
      recognized+=( "$f" )
    else
      unknown+=( "$f" )
    fi
  done

  local final_tracks=( "${recognized[@]}" )

  # If recognized < CUE track count ‚Üí fill from unknown
  if (( ${#final_tracks[@]} < cue_tracks )); then
    for f in "${unknown[@]}"; do
      final_tracks+=( "$f" )
      (( ${#final_tracks[@]} >= cue_tracks )) && break
    done
  fi

  # If more files than CUE tracks ‚Üí treat extras (e.g. pregap/hidden tracks)
  EXTRAS=()
  if (( ${#final_tracks[@]} > cue_tracks )); then
    local temp=( "${final_tracks[@]}" )
    while (( ${#temp[@]} > cue_tracks )); do
      local shortest_idx=-1
      local shortest_samples=0
      local i=0
      for f in "${temp[@]}"; do
        local samples
        samples="$(total_samples "$f")"
        if (( shortest_idx < 0 )) || (( samples < shortest_samples )); then
          shortest_idx="$i"
          shortest_samples="$samples"
        fi
        i=$((i+1))
      done
      EXTRAS+=( "${temp[$shortest_idx]}" )
      temp=( "${temp[@]:0:$shortest_idx}" "${temp[@]:$((shortest_idx+1))}" )
    done
    final_tracks=( "${temp[@]}" )
  fi

  log "CUE tracks: $cue_tracks | files after normalization: ${#final_tracks[@]} | extras: ${#EXTRAS[@]}"

  # If still mismatched, apply pregap policy
  if (( ${#final_tracks[@]} != cue_tracks )); then
    case "$PREGAP_POLICY" in
      keep)
        warn "File count (${#final_tracks[@]}) ‚â† CUE TRACK count ($cue_tracks) [policy=keep]; tagging may be inaccurate."
        ;;
      auto|drop|*)
        die "After normalization, file count (${#final_tracks[@]}) still ‚â† CUE TRACK count ($cue_tracks). Use --pregap-policy keep to force tagging."
        ;;
    esac
  fi

  # Tag tracks based on CUE
  log "Writing tags using: $CUETAG_BIN"
  "$CUETAG_BIN" "$CUE" "${final_tracks[@]}"

  # Handle extras (pregap / hidden tracks etc.)
  if (( ${#EXTRAS[@]} > 0 )); then
    handle_extras_files "${EXTRAS[@]}"
  else
    handle_extras_files
  fi

  # Embed cover
  embed_cover_to_tracks "${final_tracks[@]}"

  echo "‚úÖ Done. Split files are in: '$OUTDIR'"

  # Finally: sanitize filenames for cross-OS portability
  sanitize_output_filenames
}

main "$@"

